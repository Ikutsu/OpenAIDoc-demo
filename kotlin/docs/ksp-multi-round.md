---
title: 多轮处理
---
KSP 支持**多轮处理**（_multiple round processing_），即多次处理文件。这意味着后续的处理轮次会将前几轮的输出作为额外的输入。

## 处理器的更改

要使用多轮处理，`SymbolProcessor.process()` 函数需要返回一个无效符号的延迟符号列表（`List<KSAnnotated>`）。使用 `KSAnnotated.validate()` 来过滤无效的符号，以便延迟到下一轮处理。

以下示例代码展示了如何通过验证检查来延迟无效的符号：

```kotlin
override fun process(resolver: Resolver): List<KSAnnotated> {
    val symbols = resolver.getSymbolsWithAnnotation("com.example.annotation.Builder")
    val result = symbols.filter { !it.validate() }
    symbols
        .filter { it is KSClassDeclaration && it.validate() }
        .map { it.accept(BuilderVisitor(), Unit) }
    return result
}
```

## 多轮行为

### 将符号延迟到下一轮

处理器可以将某些符号的处理延迟到下一轮。当一个符号被延迟时，处理器会等待其他处理器提供额外的信息。它可以根据需要尽可能多地轮次延迟该符号。一旦其他处理器提供了所需的信息，该处理器就可以处理延迟的符号。处理器应该只延迟缺少必要信息的无效符号。因此，处理器**不应该** 延迟来自 classpath 的符号，KSP 也会过滤掉任何不是来自源代码的延迟符号。

例如，一个为注解类创建构建器的处理器可能需要其构造函数的所有参数类型都有效（解析为具体类型）。在第一轮中，其中一个参数类型不可解析。然后在第二轮中，由于第一轮生成的文件的影响，它变得可解析。

### 验证符号

判断一个符号是否应该被延迟的一个便捷方法是通过验证。一个处理器应该知道正确处理该符号所必需的信息。请注意，验证通常需要解析，这可能会很耗时，因此我们建议只检查所需的内容。继续前面的例子，构建器处理器的理想验证只检查带注解符号的构造函数的所有已解析参数类型是否都包含 `isError == false`。

KSP 提供了一个默认的验证实用程序。有关更多信息，请参见[高级](#advanced)部分。

### 终止条件

当完整的一轮处理没有生成任何新文件时，多轮处理就会终止。如果在满足终止条件时仍然存在未处理的延迟符号，KSP 会为每个包含未处理延迟符号的处理器记录一条错误消息。

### 每轮可访问的文件

新生成的文件和现有文件都可以通过 `Resolver` 访问。KSP 提供了两个用于访问文件的 API：`Resolver.getAllFiles()` 和 `Resolver.getNewFiles()`。`getAllFiles()` 返回现有文件和新生成文件的组合列表，而 `getNewFiles()` 仅返回新生成的文件。

### getSymbolsAnnotatedWith() 的更改

为了避免不必要的符号重新处理，`getSymbolsAnnotatedWith()` 仅返回在新生成的文件中找到的符号，以及来自上一轮的延迟符号。

### 处理器实例化

一个处理器实例只会被创建一次，这意味着你可以在处理器对象中存储信息，以便在以后的轮次中使用。

### 跨轮次信息一致性

所有 KSP 符号在多轮次中都是不可重用的，因为解析结果可能会根据前一轮中生成的内容而发生变化。但是，由于 KSP 不允许修改现有代码，因此某些信息（例如符号名称的字符串值）仍然应该是可重用的。总而言之，处理器可以存储来自前几轮的信息，但需要记住，这些信息在以后的轮次中可能无效。

### 错误和异常处理

当发生错误（由处理器调用 `KSPLogger.error()` 定义）或异常时，处理将在当前轮完成后停止。所有处理器都将调用 `onError()` 方法，而**不会**调用 `finish()` 方法。

请注意，即使发生了错误，其他处理器在该轮中仍会正常继续处理。这意味着错误处理发生在完成该轮的处理之后。

遇到异常时，KSP 将尝试区分来自 KSP 的异常和来自处理器的异常。异常将导致处理立即终止，并作为 KSPLogger 中的错误记录。来自 KSP 的异常应报告给 KSP 开发人员以进行进一步调查。在发生异常或错误的轮次结束时，所有处理器都将调用 onError() 函数来执行自己的错误处理。

KSP 为 `onError()` 提供了一个默认的无操作实现，作为 `SymbolProcessor` 接口的一部分。你可以覆盖此方法以提供你自己的错误处理逻辑。

## 高级

### 验证的默认行为

KSP 提供的默认验证逻辑会验证正在验证的符号的封闭范围内所有直接可访问的符号。默认验证检查封闭范围内的引用是否可解析为具体类型，但不会递归地深入到引用的类型中来执行验证。

### 编写你自己的验证逻辑

默认的验证行为可能并不适用于所有情况。你可以引用 `KSValidateVisitor` 并通过提供自定义的 `predicate` lambda 来编写你自己的验证逻辑，然后 `KSValidateVisitor` 使用该 lambda 过滤掉需要检查的符号。