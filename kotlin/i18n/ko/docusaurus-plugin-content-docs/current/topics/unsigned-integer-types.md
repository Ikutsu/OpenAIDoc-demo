---
title: "부호 없는 정수 형식"
---
[정수 타입](numbers#integer-types) 외에도 Kotlin은 부호 없는 정수 숫자에 대해 다음과 같은 타입을 제공합니다.

| 타입     | 크기 (비트) | 최소값 | 최대값                                       |
|----------|-------------|-----------|-------------------------------------------------|
| `UByte`  | 8           | 0         | 255                                             |
| `UShort` | 16          | 0         | 65,535                                          |
| `UInt`   | 32          | 0         | 4,294,967,295 (2<sup>32</sup> - 1)              |
| `ULong`  | 64          | 0         | 18,446,744,073,709,551,615 (2<sup>64</sup> - 1) |

부호 없는 타입은 부호 있는 타입과 거의 동일한 연산을 지원합니다.

:::note
부호 없는 숫자는 동일한 너비의 해당 부호 있는 타입 counterpart를 포함하는 단일 저장소 속성이 있는 [인라인 클래스](inline-classes)로 구현됩니다. 부호 없는 정수 타입과 부호 있는 정수 타입 간에 변환하려면 함수 호출 및 연산이 새 타입을 지원하도록 코드를 업데이트해야 합니다.

:::

## 부호 없는 배열과 범위

:::caution
부호 없는 배열과 배열에 대한 연산은 [베타](components-stability) 버전입니다. 언제든지 호환되지 않게 변경될 수 있습니다.
옵트인이 필요합니다 (자세한 내용은 아래 참조).

:::

기본 타입과 마찬가지로 각 부호 없는 타입에는 해당 타입의 배열을 나타내는 해당 타입이 있습니다.

* `UByteArray`: 부호 없는 바이트의 배열입니다.
* `UShortArray`: 부호 없는 short의 배열입니다.
* `UIntArray`: 부호 없는 int의 배열입니다.
* `ULongArray`: 부호 없는 long의 배열입니다.

부호 있는 정수 배열과 마찬가지로 boxing 오버헤드 없이 `Array` 클래스와 유사한 API를 제공합니다.

부호 없는 배열을 사용하면 이 기능이 아직 안정적이지 않다는 경고가 표시됩니다.
경고를 제거하려면 `@ExperimentalUnsignedTypes` 어노테이션으로 옵트인하십시오.
클라이언트가 API 사용에 명시적으로 옵트인해야 하는지 여부를 결정하는 것은 사용자에게 달려 있지만, 부호 없는 배열은 안정적인 기능이 아니므로 이를 사용하는 API는 언어 변경으로 인해 손상될 수 있다는 점을 명심하십시오.
[옵트인 요구 사항에 대해 자세히 알아보십시오](opt-in-requirements).

[범위 및 진행](ranges)은 `UIntRange`, `UIntProgression`, `ULongRange` 및 `ULongProgression` 클래스에 의해 `UInt` 및 `ULong`에 대해 지원됩니다. 부호 없는 정수 타입과 함께 이러한 클래스는 안정적입니다.

## 부호 없는 정수 리터럴

부호 없는 정수를 더 쉽게 사용하기 위해 특정 부호 없는 타입을 나타내는 정수 리터럴에 접미사를 추가할 수 있습니다 (예: `Float`의 `F` 또는 `Long`의 `L`).

* `u` 및 `U` 문자는 정확한 타입을 지정하지 않고 부호 없는 리터럴을 나타냅니다.
    예상 타입이 제공되지 않으면 컴파일러는 리터럴의 크기에 따라 `UInt` 또는 `ULong`을 사용합니다.

    ```kotlin
    val b: UByte = 1u  // UByte, 예상 타입 제공됨
    val s: UShort = 1u // UShort, 예상 타입 제공됨
    val l: ULong = 1u  // ULong, 예상 타입 제공됨
  
    val a1 = 42u // UInt: 예상 타입이 제공되지 않았으며 상수가 UInt에 맞습니다.
    val a2 = 0xFFFF_FFFF_FFFFu // ULong: 예상 타입이 제공되지 않았으며 상수가 UInt에 맞지 않습니다.
    ```

* `uL` 및 `UL`은 리터럴이 부호 없는 long이어야 함을 명시적으로 지정합니다.

    ```kotlin
    val a = 1UL // ULong, 예상 타입이 제공되지 않았고 상수가 UInt에 맞아도
    ```

## 사용 사례

부호 없는 숫자의 주요 사용 사례는 정수의 전체 비트 범위를 활용하여 양수 값을 나타내는 것입니다.
예를 들어, 32비트 `AARRGGBB` 형식의 색상과 같이 부호 있는 타입에 맞지 않는 16진수 상수를 나타내는 경우:

```kotlin
data class Color(val representation: UInt)

val yellow = Color(0xFFCC00CCu)
```

명시적인 `toByte()` 리터럴 캐스팅 없이 부호 없는 숫자를 사용하여 바이트 배열을 초기화할 수 있습니다.

```kotlin
val byteOrderMarkUtf8 = ubyteArrayOf(0xEFu, 0xBBu, 0xBFu)
```

또 다른 사용 사례는 네이티브 API와의 상호 운용성입니다. Kotlin을 사용하면 시그니처에 부호 없는 타입을 포함하는 네이티브 선언을 나타낼 수 있습니다. 매핑은 부호 없는 정수를 부호 있는 정수로 대체하지 않고 의미 체계를 변경하지 않은 상태로 유지합니다.

### 목표가 아닌 것

부호 없는 정수는 양수와 0만 나타낼 수 있지만, 애플리케이션 도메인에서 음수가 아닌 정수가 필요한 경우 이를 사용하는 것은 목표가 아닙니다. 예를 들어, 컬렉션 크기 또는 컬렉션 인덱스 값의 타입으로 사용되는 경우가 그렇습니다.

몇 가지 이유가 있습니다.

* 부호 있는 정수를 사용하면 [`List.lastIndex`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/last-index.html)가 빈 목록에 대해 -1인 경우와 같이 우발적인 오버플로를 감지하고 오류 조건을 알리는 데 도움이 될 수 있습니다.
* 부호 없는 정수는 값 범위가 부호 있는 정수 범위의 하위 집합이 아니기 때문에 범위가 제한된 버전의 부호 있는 정수로 취급할 수 없습니다. 부호 있는 정수와 부호 없는 정수는 서로의 하위 타입이 아닙니다.
  ```